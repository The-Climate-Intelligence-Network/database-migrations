-- Create organizations table
CREATE TABLE organizations (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  name text NOT NULL,
  description text,
  website text,
  address text,
  contact_email text,
  contact_phone text
);

-- Create players table
CREATE TABLE players (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text
);

-- Create admins table
CREATE TABLE admins (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text,
  active_organization_id uuid REFERENCES organizations(id) ON DELETE SET NULL
);

-- Create admin_memberships junction table to track which organizations admins belong to
CREATE TABLE admin_memberships (
  id bigint generated by default as identity primary key,
  admin_id uuid REFERENCES admins(id) ON DELETE CASCADE NOT NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  status text DEFAULT 'active' CHECK (status IN ('active', 'pending', 'suspended')),
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  unique (admin_id, organization_id)
);

-- Set up Row Level Security (RLS)
alter table organizations enable row level security;
alter table players enable row level security;
alter table admins enable row level security;
alter table admin_memberships enable row level security;

-- RLS Policies for organizations
create policy "Organizations are viewable by everyone." on organizations
  for select using (true);

create policy "Admins can insert organizations." on organizations
  for insert with check (exists (
    select 1 from public.user_roles 
    where user_id = (select auth.uid()) 
    and role = 'cin_admin'
    and organization_id is null
  ));

create policy "Admins can update their organizations." on organizations
  for update using (exists (
    select 1 from public.admin_memberships am
    join public.user_roles ur on am.admin_id = ur.user_id
    where am.organization_id = organizations.id
    and ur.user_id = (select auth.uid())
    and ur.role = 'org_admin'
    and ur.organization_id = organizations.id
  ) or exists (
    select 1 from public.user_roles 
    where user_id = (select auth.uid()) 
    and role = 'cin_admin'
    and organization_id is null
  ));

-- RLS Policies for players
create policy "Players profiles are viewable by everyone." on players
  for select using (true);

create policy "Players can insert their own profile." on players
  for insert with check ((select auth.uid()) = id);

create policy "Players can update own profile." on players
  for update using ((select auth.uid()) = id);

-- RLS Policies for admins
create policy "Admin profiles are viewable by everyone." on admins
  for select using (true);

create policy "Admins can insert their own profile." on admins
  for insert with check ((select auth.uid()) = id);

create policy "Admins can update own profile." on admins
  for update using ((select auth.uid()) = id);

-- RLS Policies for admin_memberships
create policy "Admin memberships are viewable by related admins." on admin_memberships
  for select using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

create policy "Admins can manage their memberships." on admin_memberships
  for all using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

-- This trigger automatically creates appropriate entries when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
declare
  user_type text;
  user_roles_array text[];
  role_item text;
  org_id uuid;
  org_name text;
begin
  -- Get user type from metadata, default to 'player' if not provided
  user_type := coalesce(new.raw_user_meta_data->>'user_type', 'player');
  
  if user_type = 'admin' then
    -- Insert into admins table
    insert into public.admins (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Handle organization creation or assignment
    org_id := (new.raw_user_meta_data->>'organization_id')::uuid;
    
    if org_id is null then
      -- Create new organization if no org_id provided
      org_name := new.raw_user_meta_data->>'organization_name';
      if org_name is not null then
        insert into public.organizations (name, contact_email)
        values (org_name, new.email)
        returning id into org_id;
      end if;
    end if;
    
    -- Link admin to organization if org_id exists
    if org_id is not null then
      insert into public.admin_memberships (admin_id, organization_id, status)
      values (new.id, org_id, 
        case 
          when (new.raw_user_meta_data->>'organization_id') is not null then 'active'
          when exists (
            select 1 from public.organization_permissions op
            where op.organization_id = org_id
              and op.permission_type in ('player_org', 'mission_creator', 'reward_creator')
              and op.status = 'approved'
          ) then 'active'
          else 'pending' 
        end
      );
      
      -- Set active organization
      update public.admins 
      set active_organization_id = org_id 
      where id = new.id;
    end if;
    
    -- Handle multiple permission types for admin
    -- Default to requesting basic player management capability
    user_roles_array := string_to_array(
      coalesce(new.raw_user_meta_data->>'permission_types', 'player_org'), 
      ','
    );
    
    -- Create organization permission requests for each type
    foreach role_item in array user_roles_array
    loop
      insert into public.organization_permissions (
        organization_id, 
        permission_type, 
        status,
        requested_by
      ) 
      values (
        org_id, 
        role_item::public.organization_permission_type,
        case when (new.raw_user_meta_data->>'organization_id') is not null then 'approved' else 'pending' end,
        new.id
      )
      on conflict (organization_id, permission_type) do nothing;
    end loop;
    
    -- Assign org_admin role to the user for this organization
    insert into public.user_roles (user_id, role, organization_id) 
    values (new.id, 'org_admin'::public.app_role, org_id);
    
  else
    -- Default case: create player (for any user_type that's not 'admin' or when user_type is null)
    insert into public.players (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Assign global player role (no organization_id)
    insert into public.user_roles (user_id, role, organization_id)
    values (new.id, 'player'::public.app_role, null);
    
  end if;
  
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');