-- Create organizations table
CREATE TABLE organizations (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  name text NOT NULL,
  description text,
  website text,
  address text,
  contact_email text,
  contact_phone text
);

-- Create players table
CREATE TABLE players (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text
);

-- Create admins table
CREATE TABLE admins (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text
);

-- Create admin_orgs junction table to track which organizations admins belong to
CREATE TABLE admin_orgs (
  id bigint generated by default as identity primary key,
  admin_id uuid REFERENCES admins(id) ON DELETE CASCADE NOT NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  unique (admin_id, organization_id)
);

-- Set up Row Level Security (RLS)
alter table organizations enable row level security;
alter table players enable row level security;
alter table admins enable row level security;
alter table admin_orgs enable row level security;

-- RLS Policies for organizations
create policy "Organizations are viewable by everyone." on organizations
  for select using (true);

create policy "Admins can insert organizations." on organizations
  for insert with check (exists (
    select 1 from public.user_roles 
    where user_id = (select auth.uid()) 
    and role in ('cin_admin_active', 'player_org_admin_active')
  ));

create policy "Admins can update their organizations." on organizations
  for update using (exists (
    select 1 from public.admin_orgs ao
    join public.user_roles ur on ao.admin_id = ur.user_id
    where ao.organization_id = organizations.id
    and ur.user_id = (select auth.uid())
    and ur.role in ('cin_admin_active', 'player_org_admin_active')
  ));

-- RLS Policies for players
create policy "Players profiles are viewable by everyone." on players
  for select using (true);

create policy "Players can insert their own profile." on players
  for insert with check ((select auth.uid()) = id);

create policy "Players can update own profile." on players
  for update using ((select auth.uid()) = id);

-- RLS Policies for admins
create policy "Admin profiles are viewable by everyone." on admins
  for select using (true);

create policy "Admins can insert their own profile." on admins
  for insert with check ((select auth.uid()) = id);

create policy "Admins can update own profile." on admins
  for update using ((select auth.uid()) = id);

-- RLS Policies for admin_orgs
create policy "Admin orgs are viewable by related admins." on admin_orgs
  for select using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin_active'
    )
  );

create policy "Admins can manage their org relationships." on admin_orgs
  for all using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin_active'
    )
  );

-- This trigger automatically creates appropriate entries when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
declare
  user_type text;
  user_roles_array text[];
  role_item text;
  org_id uuid;
  org_name text;
begin
  -- Get user type from metadata, default to 'player' if not provided
  user_type := coalesce(new.raw_user_meta_data->>'user_type', 'player');
  
  if user_type = 'admin' then
    -- Insert into admins table
    insert into public.admins (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Handle organization creation or assignment
    org_id := (new.raw_user_meta_data->>'organization_id')::uuid;
    
    if org_id is null then
      -- Create new organization if no org_id provided
      org_name := new.raw_user_meta_data->>'organization_name';
      if org_name is not null then
        insert into public.organizations (name, contact_email)
        values (org_name, new.email)
        returning id into org_id;
      end if;
    end if;
    
    -- Link admin to organization if org_id exists
    if org_id is not null then
      insert into public.admin_orgs (admin_id, organization_id)
      values (new.id, org_id);
    end if;
    
    -- Handle multiple roles for admin
    user_roles_array := string_to_array(
      coalesce(new.raw_user_meta_data->>'roles', 'cin_admin_pending'), 
      ','
    );
    
    -- Insert each role with appropriate status based on organization context
    foreach role_item in array user_roles_array
    loop
      -- If role doesn't end with status, determine status based on organization context
      if role_item not like '%_active' and role_item not like '%_pending' and role_item not like '%_inactive' then
        -- If joining existing organization, set to active; if creating new org, set to pending
        if org_id is not null and (new.raw_user_meta_data->>'organization_id') is not null then
          role_item := role_item || '_active';
        else
          role_item := role_item || '_pending';
        end if;
      end if;
      
      insert into public.user_roles (user_id, role) 
      values (new.id, role_item::public.app_role);
    end loop;
    
  else
    -- Default case: create player (for any user_type that's not 'admin' or when user_type is null)
    insert into public.players (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Default player role
    insert into public.user_roles (user_id, role) values (new.id, 'player_active');
    
  end if;
  
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');