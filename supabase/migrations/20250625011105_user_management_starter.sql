-- Create organizations table
CREATE TABLE organizations (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  name text NOT NULL,
  description text,
  website text,
  address text,
  contact_email text,
  contact_phone text
);

-- Create players table
CREATE TABLE players (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text
);

-- Create admins table
CREATE TABLE admins (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  full_name text,
  avatar_url text,
  email text,
  phone text,
  address text,
  active_organization_id uuid REFERENCES organizations(id) ON DELETE SET NULL
);

-- Create admin_memberships junction table to track which organizations admins belong to
CREATE TABLE admin_memberships (
  id bigint generated by default as identity primary key,
  admin_id uuid REFERENCES admins(id) ON DELETE CASCADE NOT NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  status text DEFAULT 'active' CHECK (status IN ('active', 'pending', 'suspended')),
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  unique (admin_id, organization_id)
);

-- Create admin invitations table
CREATE TABLE admin_invitations (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  inviter_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  invitee_email text NOT NULL,
  invitee_name text,
  permission_types text[] DEFAULT array['player_org'],
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
  token text UNIQUE NOT NULL DEFAULT gen_random_uuid()::text,
  expires_at timestamp with time zone DEFAULT (timezone('utc'::text, now()) + interval '7 days') NOT NULL,
  accepted_at timestamp with time zone,
  accepted_by uuid REFERENCES auth.users(id)
);

-- Set up Row Level Security (RLS)
alter table organizations enable row level security;
alter table players enable row level security;
alter table admins enable row level security;
alter table admin_memberships enable row level security;
alter table admin_invitations enable row level security;
alter table admin_invitations enable row level security;

-- RLS Policies for organizations
create policy "Organizations are viewable by everyone." on organizations
  for select using (true);

create policy "Admins can insert organizations." on organizations
  for insert with check (exists (
    select 1 from public.user_roles 
    where user_id = (select auth.uid()) 
    and role = 'cin_admin'
    and organization_id is null
  ));

create policy "Admins can update their organizations." on organizations
  for update using (exists (
    select 1 from public.admin_memberships am
    join public.user_roles ur on am.admin_id = ur.user_id
    where am.organization_id = organizations.id
    and ur.user_id = (select auth.uid())
    and ur.role = 'org_admin'
    and ur.organization_id = organizations.id
  ) or exists (
    select 1 from public.user_roles 
    where user_id = (select auth.uid()) 
    and role = 'cin_admin'
    and organization_id is null
  ));

-- RLS Policies for players
create policy "Players profiles are viewable by everyone." on players
  for select using (true);

create policy "Players can insert their own profile." on players
  for insert with check ((select auth.uid()) = id);

create policy "Players can update own profile." on players
  for update using ((select auth.uid()) = id);

-- RLS Policies for admins
create policy "Admin profiles are viewable by everyone." on admins
  for select using (true);

create policy "Admins can insert their own profile." on admins
  for insert with check ((select auth.uid()) = id);

create policy "Admins can update own profile." on admins
  for update using ((select auth.uid()) = id);

-- RLS Policies for admin_memberships
create policy "Admin memberships are viewable by related admins." on admin_memberships
  for select using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

create policy "Admins can manage their memberships." on admin_memberships
  for all using (
    admin_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

-- RLS Policies for admin_invitations
create policy "Admin invitations are viewable by related admins." on admin_invitations
  for select using (
    inviter_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

create policy "Admins can manage invitations." on admin_invitations
  for all using (
    inviter_id = (select auth.uid()) or
    exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

create policy "Org admins can view their organization invitations." on admin_invitations
  for select using (
    exists (
      select 1 from public.admin_memberships am
      join public.user_roles ur on am.admin_id = ur.user_id
      where am.organization_id = admin_invitations.organization_id
        and ur.user_id = (select auth.uid())
        and ur.role = 'org_admin'
        and ur.organization_id = admin_invitations.organization_id
        and am.status = 'active'
    ) or exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

create policy "Org admins can create invitations." on admin_invitations
  for insert with check (
    exists (
      select 1 from public.admin_memberships am
      join public.user_roles ur on am.admin_id = ur.user_id
      where am.organization_id = organization_id
        and ur.user_id = (select auth.uid())
        and ur.role = 'org_admin'
        and ur.organization_id = organization_id
        and am.status = 'active'
    )
  );

create policy "Org admins can update their organization invitations." on admin_invitations
  for update using (
    exists (
      select 1 from public.admin_memberships am
      join public.user_roles ur on am.admin_id = ur.user_id
      where am.organization_id = admin_invitations.organization_id
        and ur.user_id = (select auth.uid())
        and ur.role = 'org_admin'
        and ur.organization_id = admin_invitations.organization_id
        and am.status = 'active'
    ) or exists (
      select 1 from public.user_roles 
      where user_id = (select auth.uid()) 
      and role = 'cin_admin'
      and organization_id is null
    )
  );

-- This trigger automatically creates appropriate entries when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
declare
  user_type text;
  user_roles_array text[];
  role_item text;
  org_id uuid;
  org_name text;
begin
  -- Get user type from metadata, default to 'player' if not provided
  user_type := coalesce(new.raw_user_meta_data->>'user_type', 'player');
  
  if user_type = 'admin' then
    -- Insert into admins table
    insert into public.admins (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Handle organization creation or assignment
    org_id := (new.raw_user_meta_data->>'organization_id')::uuid;
    
    if org_id is null then
      -- Create new organization if no org_id provided
      org_name := new.raw_user_meta_data->>'organization_name';
      if org_name is not null then
        insert into public.organizations (name, contact_email)
        values (org_name, new.email)
        returning id into org_id;
      end if;
    end if;
    
    -- Link admin to organization if org_id exists
    if org_id is not null then
      insert into public.admin_memberships (admin_id, organization_id, status)
      values (new.id, org_id, 
        case 
          when (new.raw_user_meta_data->>'organization_id') is not null then 'active'
          when exists (
            select 1 from public.organization_permissions op
            where op.organization_id = org_id
              and op.permission_type in ('player_org', 'mission_creator', 'reward_creator')
              and op.status = 'approved'
          ) then 'active'
          else 'pending' 
        end
      );
      
      -- Set active organization
      update public.admins 
      set active_organization_id = org_id 
      where id = new.id;
    end if;
    
    -- Handle multiple permission types for admin
    user_roles_array := string_to_array(
      coalesce(new.raw_user_meta_data->>'permission_types', 'player_org'), 
      ','
    );
    
    -- Create organization permission requests for each type
    foreach role_item in array user_roles_array
    loop
      insert into public.organization_permissions (
        organization_id, 
        permission_type, 
        status,
        requested_by
      ) 
      values (
        org_id, 
        role_item::public.organization_permission_type,
        case when (new.raw_user_meta_data->>'organization_id') is not null then 'approved' else 'pending' end,
        new.id
      )
      on conflict (organization_id, permission_type) do nothing;
    end loop;
    
    -- Assign org_admin role to the user for this organization
    insert into public.user_roles (user_id, role, organization_id) 
    values (new.id, 'org_admin'::public.app_role, org_id);
    
  else
    -- Default case: create player (for any user_type that's not 'admin' or when user_type is null)
    insert into public.players (
      id, 
      full_name, 
      avatar_url, 
      email, 
      phone, 
      address
    )
    values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url', 
      new.email,
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'address'
    );
    
    -- Assign global player role (no organization_id)
    insert into public.user_roles (user_id, role, organization_id)
    values (new.id, 'player'::public.app_role, null);
    
  end if;
  
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

-- Function to invite new admins to an organization
create or replace function public.invite_admin_to_organization(
  organization_id uuid,
  email text,
  full_name text default null,
  permission_types text[] default array['player_org']
)
returns json as $$
declare
  inviter_id uuid;
  org_status text;
  invitation_id uuid;
  result json;
begin
  inviter_id := auth.uid();
  
  -- Check if inviter is an org_admin for this organization
  if not exists (
    select 1 from public.user_roles ur
    join public.admin_memberships am on ur.user_id = am.admin_id
    where ur.user_id = inviter_id
      and ur.role = 'org_admin'
      and ur.organization_id = invite_admin_to_organization.organization_id
      and am.organization_id = invite_admin_to_organization.organization_id
      and am.status = 'active'
  ) then
    return json_build_object('error', 'Unauthorized: Only active org admins can invite new admins');
  end if;
  
  -- Check if email is already invited
  if exists (
    select 1 from public.admin_invitations ai
    where ai.organization_id = invite_admin_to_organization.organization_id
      and ai.invitee_email = email
      and ai.status = 'pending'
      and ai.expires_at > now()
  ) then
    return json_build_object('error', 'Email already has a pending invitation to this organization');
  end if;
  
  -- Check organization approval status
  select case 
    when exists (
      select 1 from public.organization_permissions op
      where op.organization_id = invite_admin_to_organization.organization_id
        and op.permission_type in ('player_org', 'mission_creator', 'reward_creator')
        and op.status = 'approved'
    ) then 'approved'
    else 'pending'
  end into org_status;
  
  -- Create invitation record
  insert into public.admin_invitations (
    organization_id,
    inviter_id,
    invitee_email,
    invitee_name,
    permission_types
  ) values (
    organization_id,
    inviter_id,
    email,
    full_name,
    permission_types
  ) returning id into invitation_id;
  
  result := json_build_object(
    'invitation_id', invitation_id,
    'organization_id', organization_id,
    'inviter_email', (select email from auth.users where id = inviter_id),
    'invitee_email', email,
    'invitee_name', full_name,
    'organization_status', org_status,
    'permission_types', permission_types,
    'message', case 
      when org_status = 'approved' then 'Invitation created successfully - organization is approved'
      else 'Invitation created but organization is pending approval. Admin will have limited access until approval.'
    end
  );
  
  return result;
end;
$$ language plpgsql security definer;

-- Function to accept an admin invitation
create or replace function public.accept_admin_invitation(
  invitation_token text
)
returns json as $$
declare
  invitation_record record;
  user_id uuid;
  org_status text;
  result json;
begin
  user_id := auth.uid();
  
  -- Get invitation details
  select * into invitation_record
  from public.admin_invitations
  where token = invitation_token
    and status = 'pending'
    and expires_at > now();
  
  if not found then
    return json_build_object('error', 'Invalid or expired invitation token');
  end if;
  
  -- Check if user email matches invitation
  if not exists (
    select 1 from auth.users
    where id = user_id
      and email = invitation_record.invitee_email
  ) then
    return json_build_object('error', 'User email does not match invitation');
  end if;
  
  -- Check if user is already an admin in this organization
  if exists (
    select 1 from public.admin_memberships
    where admin_id = user_id
      and organization_id = invitation_record.organization_id
  ) then
    return json_build_object('error', 'User is already an admin in this organization');
  end if;
  
  -- Check organization approval status
  select case 
    when exists (
      select 1 from public.organization_permissions op
      where op.organization_id = invitation_record.organization_id
        and op.permission_type in ('player_org', 'mission_creator', 'reward_creator')
        and op.status = 'approved'
    ) then 'approved'
    else 'pending'
  end into org_status;
  
  -- Create admin record if doesn't exist
  insert into public.admins (
    id, 
    full_name, 
    email,
    active_organization_id
  ) values (
    user_id,
    invitation_record.invitee_name,
    invitation_record.invitee_email,
    invitation_record.organization_id
  ) on conflict (id) do update set
    active_organization_id = invitation_record.organization_id;
  
  -- Create admin membership
  insert into public.admin_memberships (
    admin_id,
    organization_id,
    status
  ) values (
    user_id,
    invitation_record.organization_id,
    case when org_status = 'approved' then 'active' else 'pending' end
  );
  
  -- Assign org_admin role
  insert into public.user_roles (user_id, role, organization_id)
  values (user_id, 'org_admin'::public.app_role, invitation_record.organization_id);
  
  -- Mark invitation as accepted
  update public.admin_invitations
  set status = 'accepted',
      accepted_at = now(),
      accepted_by = user_id,
      updated_at = now()
  where id = invitation_record.id;
  
  result := json_build_object(
    'success', true,
    'organization_id', invitation_record.organization_id,
    'membership_status', case when org_status = 'approved' then 'active' else 'pending' end,
    'message', case 
      when org_status = 'approved' then 'Successfully joined organization with full access'
      else 'Successfully joined organization. Access limited until organization approval.'
    end
  );
  
  return result;
end;
$$ language plpgsql security definer;