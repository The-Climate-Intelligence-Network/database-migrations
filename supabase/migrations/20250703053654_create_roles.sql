-- Custom types
create type public.app_permission as enum (
  'manage_organization',
  'manage_players', 
  'create_missions',
  'manage_missions',
  'create_rewards',
  'manage_rewards',
  'approve_organizations',
  'manage_cin_admins'
);

create type public.app_role as enum (
  'player',
  'cin_admin', 
  'org_admin'
);

create type public.organization_permission_type as enum (
  'player_org',
  'mission_creator', 
  'reward_creator'
);

-- USER ROLES
create table public.user_roles (
  id              bigint generated by default as identity primary key,
  user_id         uuid references auth.users on delete cascade not null,
  role            app_role not null,
  organization_id uuid references public.organizations on delete cascade,
  created_at      timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at      timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (user_id, role, organization_id)
);
comment on table public.user_roles is 'Application roles for each user, optionally scoped to an organization.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- ORGANIZATION PERMISSIONS
create table public.organization_permissions (
  id bigint generated by default as identity primary key,
  organization_id uuid references public.organizations(id) on delete cascade not null,
  permission_type organization_permission_type not null,
  status text default 'pending' check (status in ('pending', 'approved', 'rejected')),
  requested_by uuid references auth.users(id) not null,
  reviewed_by uuid references auth.users(id),
  reviewed_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (organization_id, permission_type)
);
comment on table public.organization_permissions is 'Organization permission requests and approvals for different capabilities.';

-- AUTHORIZATION FUNCTION
create or replace function public.authorize(
  requested_permission app_permission,
  organization_id uuid default null
)
returns boolean as $$
declare
  bind_permissions int;
  user_roles_jwt jsonb;
  user_orgs_jwt jsonb;
  active_org_id uuid;
begin
  -- Get user data from JWT
  user_roles_jwt := (auth.jwt() ->> 'user_roles')::jsonb;
  user_orgs_jwt := (auth.jwt() ->> 'user_organizations')::jsonb;
  active_org_id := (auth.jwt() ->> 'active_organization_id')::uuid;
  
  if user_roles_jwt is null then
    return false;
  end if;
  
  -- Use active organization if no specific org provided
  if organization_id is null then
    organization_id := active_org_id;
  end if;
  
  -- Check if user has permission through role-based permissions
  select count(*)
  into bind_permissions
  from public.role_permissions rp
  where rp.permission = requested_permission
    and rp.role::text = any(
      select jsonb_array_elements_text(
        jsonb_path_query_array(
          user_roles_jwt, 
          case 
            when organization_id is null then '$[*] ? (@.scope == "global").role'
            else '$[*] ? (@.scope == "organization" && @.organization_id == $org_id).role'
          end,
          jsonb_build_object('org_id', organization_id::text)
        )
      )
    );
  
  -- Also check if organization has the required capability (for org-specific permissions)
  if bind_permissions = 0 and organization_id is not null then
    -- Check if the organization has approved permissions for mission/reward operations
    if requested_permission in ('create_missions', 'manage_missions') then
      select count(*)
      into bind_permissions
      from public.organization_permissions op
      where op.organization_id = authorize.organization_id
        and op.permission_type = 'mission_creator'
        and op.status = 'approved';
    elsif requested_permission in ('create_rewards', 'manage_rewards') then
      select count(*)
      into bind_permissions
      from public.organization_permissions op
      where op.organization_id = authorize.organization_id
        and op.permission_type = 'reward_creator'
        and op.status = 'approved';
    elsif requested_permission in ('manage_organization', 'manage_players') then
      select count(*)
      into bind_permissions
      from public.organization_permissions op
      where op.organization_id = authorize.organization_id
        and op.permission_type = 'player_org'
        and op.status = 'approved';
    end if;
    
    -- Only grant if user is also an org_admin of that organization
    if bind_permissions > 0 then
      if not jsonb_path_exists(
        user_roles_jwt, 
        '$[*] ? (@.scope == "organization" && @.organization_id == $org_id && @.role == "org_admin")',
        jsonb_build_object('org_id', organization_id::text)
      ) then
        bind_permissions := 0;
      end if;
    end if;
  end if;
  
  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Helper function to check if organization has specific capability
create or replace function public.organization_has_capability(
  organization_id uuid,
  capability organization_permission_type
)
returns boolean as $$
declare
  has_capability boolean := false;
begin
  select exists(
    select 1 from public.organization_permissions op
    where op.organization_id = organization_has_capability.organization_id
      and op.permission_type = capability
      and op.status = 'approved'
  ) into has_capability;
  
  return has_capability;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Helper function to check organization membership
create or replace function public.is_organization_member(
  organization_id uuid
)
returns boolean as $$
declare
  user_orgs_jwt jsonb;
begin
  user_orgs_jwt := (auth.jwt() ->> 'user_organizations')::jsonb;
  
  if user_orgs_jwt is null then
    return false;
  end if;
  
  return jsonb_path_exists(
    user_orgs_jwt, 
    '$[*] ? (@.id == $org_id && @.membership_status == "active")',
    jsonb_build_object('org_id', organization_id::text)
  );
end;
$$ language plpgsql stable security definer set search_path = '';

-- Helper function to check if user has specific role in organization
create or replace function public.has_organization_role(
  role_name app_role,
  organization_id uuid
)
returns boolean as $$
declare
  user_roles_jwt jsonb;
begin
  user_roles_jwt := (auth.jwt() ->> 'user_roles')::jsonb;
  
  if user_roles_jwt is null then
    return false;
  end if;
  
  return jsonb_path_exists(
    user_roles_jwt, 
    '$[*] ? (@.scope == "organization" && @.organization_id == $org_id && @.role == $role)',
    jsonb_build_object('org_id', organization_id::text, 'role', role_name::text)
  );
end;
$$ language plpgsql stable security definer set search_path = '';

-- Helper function to get user's active organization capabilities
create or replace function public.get_active_org_capabilities()
returns jsonb as $$
declare
  active_org_id uuid;
  capabilities jsonb := '[]'::jsonb;
  cap_record record;
begin
  active_org_id := (auth.jwt() ->> 'active_organization_id')::uuid;
  
  if active_org_id is null then
    return capabilities;
  end if;
  
  for cap_record in
    select permission_type, status
    from public.organization_permissions
    where organization_id = active_org_id
  loop
    capabilities := capabilities || jsonb_build_object(
      'type', cap_record.permission_type,
      'status', cap_record.status
    );
  end loop;
  
  return capabilities;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Populate role permissions
INSERT INTO public.role_permissions (role, permission) VALUES
  -- CIN Admin permissions (global access)
  ('cin_admin', 'approve_organizations'),
  ('cin_admin', 'manage_cin_admins'),
  ('cin_admin', 'manage_organization'),
  ('cin_admin', 'manage_players'),
  ('cin_admin', 'create_missions'),
  ('cin_admin', 'manage_missions'),
  ('cin_admin', 'create_rewards'),
  ('cin_admin', 'manage_rewards'),
  
  -- Org Admin permissions (organization-scoped, but also checked via organization_permissions)
  ('org_admin', 'manage_organization'),
  ('org_admin', 'manage_players');

-- Set up Row Level Security (RLS) for role_permissions
alter table role_permissions enable row level security;

-- RLS Policies for role_permissions
create policy "Role permissions are viewable by authenticated users." on role_permissions
  for select using (true); -- This is reference data that needs to be readable

create policy "Only CIN admins can manage role permissions." on role_permissions
  for all using (exists (
    select 1 from public.user_roles ur
    where ur.user_id = (select auth.uid())
    and ur.role = 'cin_admin'
    and ur.organization_id is null
  ));

-- Set up Row Level Security (RLS) for user_roles
alter table user_roles enable row level security;

-- RLS Policies for user_roles
create policy "Users can view their own roles." on user_roles
  for select using (user_id = (select auth.uid()));

create policy "Only CIN admins can manage user roles." on user_roles
  for all using (exists (
    select 1 from public.user_roles ur
    where ur.user_id = (select auth.uid())
    and ur.role = 'cin_admin'
    and ur.organization_id is null
  ));

-- Set up Row Level Security (RLS) for organization_permissions  
alter table organization_permissions enable row level security;

-- RLS Policies for organization_permissions
create policy "Users can view organization permissions." on organization_permissions
  for select using (
    -- Requesters can see their own requests
    requested_by = (select auth.uid()) or
    -- Org admins can see permissions for their organizations
    exists (
      select 1 from public.admin_memberships am
      join public.user_roles ur on am.admin_id = ur.user_id
      where am.organization_id = organization_permissions.organization_id
        and ur.user_id = (select auth.uid())
        and ur.role = 'org_admin'
        and am.status = 'active'
    ) or
    -- CIN admins can see all
    exists (
      select 1 from public.user_roles ur
      where ur.user_id = (select auth.uid())
      and ur.role = 'cin_admin'
      and ur.organization_id is null
    )
  );

create policy "Only CIN admins can manage organization permissions." on organization_permissions
  for all using (exists (
    select 1 from public.user_roles ur
    where ur.user_id = (select auth.uid())
    and ur.role = 'cin_admin'
    and ur.organization_id is null
  ));